"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const db_1 = require("./db");
let db;
beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
    db = yield db_1.connect();
}));
beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
    db.testCol.pkPrefix = undefined;
    yield db.testCol.deleteMany({});
}));
afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
    yield db.disconnect(true);
}));
test('prefixes generated ids with pkPrefix', () => __awaiter(void 0, void 0, void 0, function* () {
    const result1 = yield db.testCol.insertOne({ name: 'john' });
    expect(result1.insertedId).toHaveLength(17);
    db.testCol.pkPrefix = 'usr_';
    const result2 = yield db.testCol.insertOne({ name: 'john' });
    expect(result2.insertedId).toHaveLength(21);
    expect(result2.insertedId).toMatch(/^usr_/);
}));
test('still allows for server side id generation', () => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const connection = yield db_1.connect(undefined, {
        forceServerObjectId: true,
    });
    const col = connection.testCol;
    // insert
    const insertOneResult = yield col.insertOne({ name: 'john' });
    expect(typeof insertOneResult.insertedId).not.toEqual('string');
    const insertManyResult = yield col.insertMany([{ name: 'john' }]);
    Object.values(insertManyResult.insertedIds).forEach((id) => {
        expect(typeof id).not.toEqual('string');
    });
    // update
    const updateOneResult = yield col.updateOne({ name: 'john' }, { $set: { name: 'john doe' } }, { upsert: true });
    expect(typeof updateOneResult.upsertedId).not.toEqual('string');
    const updateManyResult = yield col.updateMany({ name: 'john' }, { $set: { name: 'john doe' } }, { upsert: true });
    expect(typeof updateManyResult.upsertedId).not.toEqual('string');
    // bulk
    const bulk = yield col.initializeOrderedBulkOp();
    bulk.insert({ hi: 'there' });
    const bulkResult = yield bulk.execute();
    const [inserted] = bulkResult.getInsertedIds();
    expect(typeof inserted._id).not.toEqual('string');
    // bulk write
    const bulkWrite = yield col.bulkWrite([
        { insertOne: { document: { hi: 'there' } } },
    ]);
    expect(typeof ((_a = bulkWrite.insertedIds) === null || _a === void 0 ? void 0 : _a[0])).not.toEqual('string');
    yield connection.disconnect();
}));
test('cursor methods are returning results directly', () => __awaiter(void 0, void 0, void 0, function* () {
    const docs = [{ test: 1 }, { test: 2 }, { test: 3 }];
    yield db.testCol.insertMany(docs);
    const findResult = yield db.testCol.find({ test: { $exists: true } });
    expect(findResult).toMatchPartial(docs);
    const aggregateResult = yield db.testCol.aggregate([
        {
            $match: { test: { $exists: true } },
        },
    ]);
    expect(aggregateResult).toMatchPartial(docs);
    const indexResult = yield db.testCol.listIndexes();
    expect(indexResult).toMatchPartial([
        {
            name: '_id_',
            ns: 'test.testCol',
        },
    ]);
}));
test('insertOne is augmented', () => __awaiter(void 0, void 0, void 0, function* () {
    const result = yield db.testCol.insertOne({ name: 'john' });
    expect(typeof result.insertedId).toEqual('string');
}));
test('insertMany is augmented', () => __awaiter(void 0, void 0, void 0, function* () {
    const result = yield db.testCol.insertMany([
        { name: 'john' },
        { name: 'hi' },
    ]);
    Object.values(result.insertedIds).forEach((id) => {
        expect(typeof id).toEqual('string');
    });
}));
test('updateOne is augmented', () => __awaiter(void 0, void 0, void 0, function* () {
    const { insertedId } = yield db.testCol.insertOne({ name: 'john' });
    const { modifiedCount } = yield db.testCol.updateOne({ _id: insertedId }, { $set: { name: 'john doe' } });
    expect(modifiedCount).toEqual(1);
}));
test('updateMany is augmented', () => __awaiter(void 0, void 0, void 0, function* () {
    const { insertedId } = yield db.testCol.insertOne({ name: 'john' });
    const { modifiedCount } = yield db.testCol.updateMany({ _id: insertedId }, { $set: { name: 'john doe' } });
    const { upsertedId } = yield db.testCol.updateMany({ name: 'update-many-upsert ' }, { $set: { name: 'john doe' } }, { upsert: true });
    expect(modifiedCount).toEqual(1);
    expect(typeof upsertedId._id).toEqual('string');
}));
test('updateOne.upsert is augmented', () => __awaiter(void 0, void 0, void 0, function* () {
    const { upsertedId } = yield db.testCol.updateOne({ name: 'updateOne.upsert' }, { $set: { name: 'updateOne.upsert-updated' } }, { upsert: true });
    expect(typeof upsertedId._id).toEqual('string');
}));
test('updateMany.upsert is augmented', () => __awaiter(void 0, void 0, void 0, function* () {
    const { upsertedId } = yield db.testCol.updateMany({ _id: 'updateMany.upsert' }, { $set: { name: 'updateOne.upsert-updated' } }, { upsert: true });
    expect(typeof upsertedId._id).toEqual('string');
}));
test('findOneAndUpdate is augmented', () => __awaiter(void 0, void 0, void 0, function* () {
    db.testCol.pkPrefix = 'job_';
    const { value } = yield db.testCol.findOneAndUpdate({ name: 'job' }, { $set: { started: new Date() } }, { upsert: true, returnDocument: 'after' });
    expect(value._id).toMatch(/^job_/);
    expect(typeof value._id).toEqual('string');
}));
test('bulk insert is augmented', () => __awaiter(void 0, void 0, void 0, function* () {
    const bulk = yield db.testCol.initializeOrderedBulkOp();
    bulk.insert({ name: 'john' });
    const result = yield bulk.execute();
    const insertedIds = result.getInsertedIds();
    insertedIds.forEach(({ _id }) => {
        expect(typeof _id).toEqual('string');
    });
}));
test('bulk upsert is augmented', () => __awaiter(void 0, void 0, void 0, function* () {
    const bulk = yield db.testCol.initializeOrderedBulkOp();
    bulk
        .find({ name: 'john' })
        .upsert()
        .updateOne({ $setOnInsert: { name: 'john doe' } });
    bulk
        .find({ _id: '123' })
        .upsert()
        .updateOne({ $setOnInsert: { name: 'john doe' } });
    bulk.find({ _id: '456' }).update({ $set: { name: 'john' } });
    const result = yield bulk.execute();
    result.getUpsertedIds().forEach(({ _id }) => {
        expect(typeof _id).toEqual('string');
    });
}));
test('bulkWrite.insertOne is augmented', () => __awaiter(void 0, void 0, void 0, function* () {
    const result = yield db.testCol.bulkWrite([
        { insertOne: { document: { name: 'john' } } },
        // @ts-ignore
        { insertOne: { name: 'john' } },
    ]);
    // @ts-ignore
    const insertedIds = Object.values(result.insertedIds);
    insertedIds.forEach((_id) => {
        expect(typeof _id).toEqual('string');
    });
}));
test('bulkWrite.update is augmented', () => __awaiter(void 0, void 0, void 0, function* () {
    const result = yield db.testCol.bulkWrite([
        {
            updateOne: {
                filter: { name: 'jack' },
                update: { $set: { name: 'jack doe' } },
                upsert: true,
            },
        },
        {
            updateMany: {
                filter: { name: 'jane' },
                update: { $set: { name: 'jane doe' } },
                upsert: true,
            },
        },
    ]);
    // @ts-ignore
    const insertedIds = Object.values(result.upsertedIds);
    insertedIds.forEach((_id) => {
        expect(typeof _id).toEqual('string');
    });
}));
test('supports transactions', () => __awaiter(void 0, void 0, void 0, function* () {
    const { insertedId } = yield db.testCol.insertOne({
        name: 'transaction test',
        count: 0,
    });
    // first failing transaction
    yield expect(db.transaction((session) => __awaiter(void 0, void 0, void 0, function* () {
        yield db.testCol.updateOne({ _id: insertedId }, { $inc: { count: 1 } }, { session });
        throw new Error('do not commit!');
    }))).rejects.toThrow('do not commit!');
    // now a succeeding transaction
    yield expect(db.transaction((session) => __awaiter(void 0, void 0, void 0, function* () {
        yield db.testCol.updateOne({ _id: insertedId }, { $inc: { count: 1 } }, { session });
    }))).resolves.toBeTruthy();
    // validate that the count was only increased once
    yield expect(db.testCol.findOne({ _id: insertedId })).resolves.toMatchPartial({
        name: 'transaction test',
        count: 1,
    });
}));
//# sourceMappingURL=db.test.js.map