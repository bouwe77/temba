"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCollection = void 0;
const collection_1 = __importDefault(require("mongodb/lib/collection"));
const common_1 = require("mongodb/lib/bulk/common");
const connection_1 = require("./connection/connection");
function isCursor(res) {
    return typeof (res === null || res === void 0 ? void 0 : res.then) !== 'function' && typeof (res === null || res === void 0 ? void 0 : res.toArray) === 'function';
}
function wrapCursor(method, args, res) {
    var _a, _b, _c;
    switch (method) {
        case 'find':
            return ((_a = args[1]) === null || _a === void 0 ? void 0 : _a.rawCursor) ? res : res.toArray();
        case 'aggregate':
            return ((_b = args[1]) === null || _b === void 0 ? void 0 : _b.rawCursor) ? res : res.toArray();
        case 'listIndexes':
            return ((_c = args[0]) === null || _c === void 0 ? void 0 : _c.rawCursor) ? res : res.toArray();
        default:
            /* istanbul ignore next */
            return res;
    }
}
// This method turns ALL mongo methods into promisses. That means that there
// there are a few differences with the native mongodb driver.
//   collection.find, now returns a Promise<T[]> unless queried with rawCursor
//   collection.aggregate, now returns a Promise<T[]>, unless queried with rawCursor
//   collection.listIndexes, now returns a Promise<T[]>, unless queried with rawCursor
//   collection.initializeOrderedBulkOp now returns a Promise<void>
//   collection.initializeUnorderedBulkOp now returns a Promise<void>
function getCollection({ getInstance, name }) {
    return new Proxy({ pkPrefix: '' }, {
        get: function (obj, method) {
            if (typeof method !== 'string' || typeof obj[method] !== 'undefined') {
                return obj[method];
            }
            if (method === 'pkPrefix') {
                return obj.pkPrefix;
            }
            return (...args) => __awaiter(this, void 0, void 0, function* () {
                const db = yield getInstance();
                const collection = db.collection(name);
                const res = collection[method](...args);
                return isCursor(res) ? wrapCursor(method, args, res) : res;
            });
        },
    });
}
exports.getCollection = getCollection;
function forceServerObjectId(instance) {
    var _a;
    // I can't seem to touch this line, even tho this is what the native driver
    // uses. Instead, we have the settings a bit lower, mentioning the weird thing.
    if (typeof instance.s.options.forceServerObjectId === 'boolean') {
        /* istanbul ignore next */
        return instance.s.options.forceServerObjectId;
    }
    // weird thing, native driver doesn't check here, but this is where the settings are :/
    if (typeof ((_a = instance.s.db) === null || _a === void 0 ? void 0 : _a.s.options.forceServerObjectId) === 'boolean') {
        return instance.s.db.s.options.forceServerObjectId;
    }
    if (instance.s.collection) {
        return instance.s.collection.s.db.options.forceServerObjectId;
    }
    return false;
}
function createPk(instance) {
    const collection = instance.s.collection || instance;
    const options = {
        dbName: collection.dbName,
        collectionName: collection.collectionName,
    };
    return collection.s.pkFactory.createPk(options);
}
collection_1.default.prototype.paginate = function findPage(filter, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return connection_1.getConnection(this, filter, options);
    });
};
const _insertOne = collection_1.default.prototype.insertOne;
collection_1.default.prototype.insertOne = function insertOne(doc, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
            return _insertOne.apply(this, [doc, options]);
        }
        doc._id = doc._id || createPk(this);
        return _insertOne.apply(this, [doc, options]);
    });
};
const _insertMany = collection_1.default.prototype.insertMany;
collection_1.default.prototype.insertMany = function insertMany(docs, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
            return _insertMany.apply(this, [docs, options]);
        }
        for (const doc of docs) {
            doc._id = doc._id || createPk(this);
        }
        return _insertMany.apply(this, [docs, options]);
    });
};
const _updateOne = collection_1.default.prototype.updateOne;
collection_1.default.prototype.updateOne = function updateOne(filter, update, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
            return _updateOne.apply(this, [filter, update, options]);
        }
        if (options.upsert && !filter._id) {
            update.$setOnInsert = update.$setOnInsert || {};
            update.$setOnInsert._id = update.$setOnInsert._id || createPk(this);
        }
        return _updateOne.apply(this, [filter, update, options]);
    });
};
const _updateMany = collection_1.default.prototype.updateMany;
collection_1.default.prototype.updateMany = function updateMany(filter, update, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
            return _updateMany.apply(this, [filter, update, options]);
        }
        if (options.upsert && !filter._id) {
            update.$setOnInsert = update.$setOnInsert || {};
            update.$setOnInsert._id = update.$setOnInsert._id || createPk(this);
        }
        return _updateMany.apply(this, [filter, update, options]);
    });
};
const _findOneAndUpdate = collection_1.default.prototype.findOneAndUpdate;
collection_1.default.prototype.findOneAndUpdate = function findOneAndUpdate(filter, update, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
            return _findOneAndUpdate.apply(this, [filter, update, options]);
        }
        if (options.upsert && !filter._id) {
            update.$setOnInsert = update.$setOnInsert || {};
            update.$setOnInsert._id = update.$setOnInsert._id || createPk(this);
        }
        return _findOneAndUpdate.apply(this, [filter, update, options]);
    });
};
const _bulkInsert = common_1.BulkOperationBase.prototype.insert;
common_1.BulkOperationBase.prototype.insert = function insert(doc) {
    if (forceServerObjectId(this)) {
        return _bulkInsert.apply(this, [doc]);
    }
    doc._id = doc._id || createPk(this);
    return _bulkInsert.apply(this, [doc]);
};
const _bulkRaw = common_1.BulkOperationBase.prototype.raw;
common_1.BulkOperationBase.prototype.raw = function raw(op) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
            return _bulkRaw.apply(this, [op]);
        }
        // Update operations, note that we cannot generate ids for updateMany ops
        if (((_a = op.updateOne) === null || _a === void 0 ? void 0 : _a.upsert) && !((_b = op.updateOne.filter) === null || _b === void 0 ? void 0 : _b._id)) {
            const update = op.updateOne.update;
            update.$setOnInsert = update.$setOnInsert || {};
            update.$setOnInsert._id = update.$setOnInsert._id || createPk(this);
        }
        // Note that this WILL give issues when the upsert results in multiple upserts,
        // but who does that! The docs do mention:
        //   _To avoid multiple upserts, ensure that filter fields are uniquely indexed_
        if (((_c = op.updateMany) === null || _c === void 0 ? void 0 : _c.upsert) && !((_d = op.updateMany.filter) === null || _d === void 0 ? void 0 : _d._id)) {
            const update = op.updateMany.update;
            update.$setOnInsert = update.$setOnInsert || {};
            update.$setOnInsert._id = update.$setOnInsert._id || createPk(this);
        }
        // Insert operations
        if ((_e = op.insertOne) === null || _e === void 0 ? void 0 : _e.document) {
            op.insertOne.document._id = op.insertOne.document._id || createPk(this);
        }
        else if (op.insertOne) {
            op.insertOne._id = op.insertOne._id || createPk(this);
        }
        if (op.insertMany) {
            for (let i = 0; i < op.insertMany.length; i++) {
                op.insertMany[i]._id = op.insertMany[i]._id || createPk(this);
            }
        }
        return _bulkRaw.apply(this, [op]);
    });
};
const _bulkFind = common_1.BulkOperationBase.prototype.find;
common_1.BulkOperationBase.prototype.find = function find(selector) {
    const op = _bulkFind.apply(this, [selector]);
    const _update = op.update;
    op.update = function update(document) {
        return _update.apply(this, [document]);
    };
    const _updateOne = op.updateOne;
    op.updateOne = function updateOne(document) {
        if (this.s.currentOp.upsert && !selector._id) {
            document.$setOnInsert = document.$setOnInsert || {};
            document.$setOnInsert._id = document.$setOnInsert._id || createPk(this);
        }
        return _updateOne.apply(this, [document]);
    };
    return op;
};
//# sourceMappingURL=collection.js.map