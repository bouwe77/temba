"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.connect = exports.create = void 0;
// NOTE: Import order matters!, import the prototype extensions before MongoClient
require("./collection");
const mongodb_1 = require("mongodb");
const picoid_1 = __importDefault(require("picoid"));
const collection_1 = require("./collection");
function create(uri = process.env.MONGO_URL || 'mongodb://localhost:27017', options) {
    let client;
    let db;
    const collections = {};
    let instancePromise;
    function createPk({ collectionName }) {
        if (collections[collectionName].pkPrefix) {
            return collections[collectionName].pkPrefix + picoid_1.default();
        }
        return picoid_1.default();
    }
    const clientOptions = Object.assign({
        useNewUrlParser: true,
        useUnifiedTopology: true,
        pkFactory: { createPk },
    }, options);
    function getInstance() {
        return __awaiter(this, void 0, void 0, function* () {
            if (instancePromise) {
                return instancePromise;
            }
            instancePromise = new Promise((resolve) => {
                mongodb_1.MongoClient.connect(uri, clientOptions).then((mongoClient) => {
                    client = mongoClient;
                    db = client.db();
                    resolve(db);
                });
            });
            return instancePromise;
        });
    }
    function connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield getInstance();
        });
    }
    function disconnect(force) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!client) {
                /* istanbul ignore next */
                return;
            }
            yield client.close(force);
        });
    }
    function transaction(fn, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield connect();
            if (!client) {
                throw new Error('Client is undefined o.O');
            }
            const session = client.startSession();
            try {
                return yield session.withTransaction(() => fn(session), options);
            }
            finally {
                yield session.endSession();
            }
        });
    }
    if ((options === null || options === void 0 ? void 0 : options.autoDisconnect) !== false) {
        process.on('exit', () => {
            disconnect(true).catch(() => undefined);
        });
    }
    return new Proxy({}, {
        get: function (obj, name) {
            if (typeof name !== 'string' || typeof obj[name] !== 'undefined') {
                /* istanbul ignore next */
                return obj[name];
            }
            if (db === null || db === void 0 ? void 0 : db.hasOwnProperty(name)) {
                /* istanbul ignore next */
                return db[name];
            }
            if (name === 'transaction') {
                return transaction;
            }
            if (name === 'connect') {
                return connect;
            }
            if (name === 'disconnect') {
                return disconnect;
            }
            if (collections[name]) {
                return collections[name];
            }
            collections[name] = collection_1.getCollection({ name, getInstance });
            return collections[name];
        },
    });
}
exports.create = create;
function connect(uri, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const db = create(uri, options);
        yield db.connect();
        return db;
    });
}
exports.connect = connect;
//# sourceMappingURL=db.js.map