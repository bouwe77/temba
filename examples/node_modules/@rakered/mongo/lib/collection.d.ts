import { ClientSession, Collection as MongoCollection, CollectionAggregationOptions, CommonOptions, FilterQuery, FindOneOptions, OrderedBulkOperation, ReadPreferenceOrMode, UnorderedBulkOperation } from 'mongodb';
import { Connection, ConnectionOptions } from './connection/connection';
interface ListIndexOptions {
    batchSize?: number;
    readPreference?: ReadPreferenceOrMode;
    session?: ClientSession;
}
interface IndexResult {
    v: number;
    key: {
        _id: number;
    };
    name: string;
    ns: string;
    unique: boolean;
    sparse: boolean;
}
export declare type Collection<TSchema> = Omit<MongoCollection<TSchema>, 'find' | 'aggregate' | 'listIndexes' | 'initializeOrderedBulkOp' | 'initializeUnorderedBulkOp'> & {
    pkPrefix?: string;
    find<T = TSchema>(query?: FilterQuery<TSchema>, options?: FindOneOptions<T extends TSchema ? TSchema : T>): Promise<T[]>;
    aggregate<T = TSchema>(pipeline?: object, options?: CollectionAggregationOptions): Promise<T[]>;
    paginate<T = TSchema>(query1: FilterQuery<TSchema>, options?: ConnectionOptions<T extends TSchema ? TSchema : T>): Promise<Connection<T>>;
    paginate<T = TSchema>(query2: FilterQuery<TSchema>, options: ConnectionOptions<T extends TSchema ? TSchema : T> & {
        type: 'nodes';
    }): Promise<Omit<Connection<T>, 'edges'>>;
    paginate<T = TSchema>(query3: FilterQuery<TSchema>, options: ConnectionOptions<T extends TSchema ? TSchema : T> & {
        type: 'edges';
    }): Promise<Omit<Connection<T>, 'nodes'>>;
    listIndexes(options?: ListIndexOptions): Promise<IndexResult[]>;
    initializeOrderedBulkOp(options?: CommonOptions): Promise<OrderedBulkOperation>;
    initializeUnorderedBulkOp(options?: CommonOptions): Promise<UnorderedBulkOperation>;
};
export declare function getCollection({ getInstance, name }: {
    getInstance: any;
    name: any;
}): {
    pkPrefix: string;
};
export {};
