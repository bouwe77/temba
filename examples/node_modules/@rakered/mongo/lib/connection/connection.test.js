"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const db_1 = require("../db");
const cursor_1 = require("./cursor");
let db;
beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
    db = yield db_1.connect();
    db.connectionCol.pkPrefix = 'con_';
}));
beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
    yield db.connectionCol.deleteMany({});
    const docs = Array.from({ length: 8 }).map((_, idx) => ({
        _id: `doc_${idx}`,
        name: `doc ${(idx + 1 + '').padStart(2, '0')}`,
        index: idx,
        created: 1000 + idx,
    }));
    yield db.connectionCol.insertMany(docs);
}));
afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
    yield db.disconnect(true);
}));
test('can paginate forward', () => __awaiter(void 0, void 0, void 0, function* () {
    const page1 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'asc'],
        first: 3,
    });
    expect(page1.nodes).toHaveLength(3);
    expect(page1.nodes[0]).toMatchPartial({ name: 'doc 01' });
    expect(page1.nodes[1]).toMatchPartial({ name: 'doc 02' });
    expect(page1.nodes[2]).toMatchPartial({ name: 'doc 03' });
    expect(page1).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: false,
            hasNextPage: true,
            startCursor: cursor_1.getCursor(page1.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page1.nodes[2], 'name'),
        },
    });
    const page2 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'asc'],
        first: 3,
        after: page1.pageInfo.endCursor,
    });
    expect(page2.nodes).toHaveLength(3);
    expect(page2.nodes[0]).toMatchPartial({ name: 'doc 04' });
    expect(page2.nodes[1]).toMatchPartial({ name: 'doc 05' });
    expect(page2.nodes[2]).toMatchPartial({ name: 'doc 06' });
    expect(page2).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: true,
            hasNextPage: true,
            startCursor: cursor_1.getCursor(page2.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page2.nodes[2], 'name'),
        },
    });
    const page3 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'asc'],
        first: 3,
        after: page2.pageInfo.endCursor,
    });
    expect(page3.nodes).toHaveLength(2);
    expect(page3.nodes[0]).toMatchPartial({ name: 'doc 07' });
    expect(page3.nodes[1]).toMatchPartial({ name: 'doc 08' });
    expect(page3).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: true,
            hasNextPage: false,
            startCursor: cursor_1.getCursor(page3.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page3.nodes[1], 'name'),
        },
    });
}));
test('can paginate forward in reverse', () => __awaiter(void 0, void 0, void 0, function* () {
    const page1 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'desc'],
        first: 3,
    });
    expect(page1.nodes).toHaveLength(3);
    expect(page1.nodes[0]).toMatchPartial({ name: 'doc 08' });
    expect(page1.nodes[1]).toMatchPartial({ name: 'doc 07' });
    expect(page1.nodes[2]).toMatchPartial({ name: 'doc 06' });
    expect(page1).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: false,
            hasNextPage: true,
            startCursor: cursor_1.getCursor(page1.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page1.nodes[2], 'name'),
        },
    });
    const page2 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'desc'],
        first: 3,
        after: page1.pageInfo.endCursor,
    });
    expect(page2.nodes).toHaveLength(3);
    expect(page2.nodes[0]).toMatchPartial({ name: 'doc 05' });
    expect(page2.nodes[1]).toMatchPartial({ name: 'doc 04' });
    expect(page2.nodes[2]).toMatchPartial({ name: 'doc 03' });
    expect(page2).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: true,
            hasNextPage: true,
            startCursor: cursor_1.getCursor(page2.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page2.nodes[2], 'name'),
        },
    });
    const page3 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'desc'],
        first: 3,
        after: page2.pageInfo.endCursor,
    });
    expect(page3.nodes).toHaveLength(2);
    expect(page3.nodes[0]).toMatchPartial({ name: 'doc 02' });
    expect(page3.nodes[1]).toMatchPartial({ name: 'doc 01' });
    expect(page3).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: true,
            hasNextPage: false,
            startCursor: cursor_1.getCursor(page3.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page3.nodes[1], 'name'),
        },
    });
}));
test('can paginate backward', () => __awaiter(void 0, void 0, void 0, function* () {
    const page1 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'asc'],
        last: 3,
    });
    expect(page1.nodes).toHaveLength(3);
    expect(page1.nodes[0]).toMatchPartial({ name: 'doc 06' });
    expect(page1.nodes[1]).toMatchPartial({ name: 'doc 07' });
    expect(page1.nodes[2]).toMatchPartial({ name: 'doc 08' });
    expect(page1).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: true,
            hasNextPage: false,
            startCursor: cursor_1.getCursor(page1.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page1.nodes[2], 'name'),
        },
    });
    const page2 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'asc'],
        last: 3,
        before: page1.pageInfo.startCursor,
    });
    expect(page2.nodes).toHaveLength(3);
    expect(page2.nodes[0]).toMatchPartial({ name: 'doc 03' });
    expect(page2.nodes[1]).toMatchPartial({ name: 'doc 04' });
    expect(page2.nodes[2]).toMatchPartial({ name: 'doc 05' });
    expect(page2).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: true,
            hasNextPage: true,
            startCursor: cursor_1.getCursor(page2.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page2.nodes[2], 'name'),
        },
    });
    const page3 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'asc'],
        last: 3,
        before: page2.pageInfo.startCursor,
    });
    expect(page3.nodes).toHaveLength(2);
    expect(page3.nodes[0]).toMatchPartial({ name: 'doc 01' });
    expect(page3.nodes[1]).toMatchPartial({ name: 'doc 02' });
    expect(page3).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: false,
            hasNextPage: true,
            startCursor: cursor_1.getCursor(page3.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page3.nodes[1], 'name'),
        },
    });
}));
test('can paginate backward in reverse', () => __awaiter(void 0, void 0, void 0, function* () {
    const page1 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'desc'],
        last: 3,
    });
    expect(page1.nodes).toHaveLength(3);
    expect(page1.nodes[0]).toMatchPartial({ name: 'doc 03' });
    expect(page1.nodes[1]).toMatchPartial({ name: 'doc 02' });
    expect(page1.nodes[2]).toMatchPartial({ name: 'doc 01' });
    expect(page1).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: true,
            hasNextPage: false,
            startCursor: cursor_1.getCursor(page1.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page1.nodes[2], 'name'),
        },
    });
    const page2 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'desc'],
        last: 3,
        before: page1.pageInfo.startCursor,
    });
    expect(page2.nodes).toHaveLength(3);
    expect(page2.nodes[0]).toMatchPartial({ name: 'doc 06' });
    expect(page2.nodes[1]).toMatchPartial({ name: 'doc 05' });
    expect(page2.nodes[2]).toMatchPartial({ name: 'doc 04' });
    expect(page2).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: true,
            hasNextPage: true,
            startCursor: cursor_1.getCursor(page2.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page2.nodes[2], 'name'),
        },
    });
    const page3 = yield db.connectionCol.paginate({}, {
        sort: ['name', 'desc'],
        last: 3,
        before: page2.pageInfo.startCursor,
    });
    expect(page3.nodes).toHaveLength(2);
    expect(page3.nodes[0]).toMatchPartial({ name: 'doc 08' });
    expect(page3.nodes[1]).toMatchPartial({ name: 'doc 07' });
    expect(page3).toMatchPartial({
        totalCount: 8,
        pageInfo: {
            hasPreviousPage: false,
            hasNextPage: true,
            startCursor: cursor_1.getCursor(page3.nodes[0], 'name'),
            endCursor: cursor_1.getCursor(page3.nodes[1], 'name'),
        },
    });
}));
test('can paginate on id', () => __awaiter(void 0, void 0, void 0, function* () {
    const page1 = yield db.connectionCol.paginate({}, {
        first: 3,
    });
    expect(page1.nodes).toHaveLength(3);
    expect(page1.nodes[0]).toMatchPartial({ name: 'doc 01' });
    expect(page1.nodes[1]).toMatchPartial({ name: 'doc 02' });
    expect(page1.nodes[2]).toMatchPartial({ name: 'doc 03' });
    const page2 = yield db.connectionCol.paginate({}, {
        first: 3,
        after: page1.pageInfo.endCursor,
    });
    expect(page2.nodes).toHaveLength(3);
    expect(page2.nodes[0]).toMatchPartial({ name: 'doc 04' });
    expect(page2.nodes[1]).toMatchPartial({ name: 'doc 05' });
    expect(page2.nodes[2]).toMatchPartial({ name: 'doc 06' });
}));
test('can paginate on edge|node|all types', () => __awaiter(void 0, void 0, void 0, function* () {
    const col = db.connectionCol;
    const hybrid = yield col.paginate({}, { first: 3 });
    expect(hybrid).toHaveProperty('nodes');
    expect(hybrid).toHaveProperty('edges');
    const edges = yield col.paginate({}, { first: 3, type: 'edges' });
    expect(edges).not.toHaveProperty('nodes');
    expect(edges).toHaveProperty('edges');
    const nodes = yield col.paginate({}, { first: 3, type: 'nodes' });
    expect(nodes).toHaveProperty('nodes');
    expect(nodes).not.toHaveProperty('edges');
}));
//# sourceMappingURL=connection.test.js.map