"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConnection = void 0;
const cursor_1 = require("./cursor");
const validatePaginationArgs_1 = require("./validatePaginationArgs");
function getConnection(collection, query, options = {}) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, void 0, void 0, function* () {
        validatePaginationArgs_1.validatePaginationArgs(options);
        const { projection, after, before, first, last } = options;
        // flip sort dir when querying backwards
        const orderBy = ((_a = options.sort) === null || _a === void 0 ? void 0 : _a[0]) || '_id';
        const orderDir = (((_b = options.sort) === null || _b === void 0 ? void 0 : _b[1]) === 'desc' ? -1 : 1) * (last ? -1 : 1);
        const operation = orderDir === 1 ? '$gt' : '$lt';
        // construct sort options
        const sort = orderBy === '_id'
            ? [[orderBy, orderDir]]
            : [
                [orderBy, orderDir],
                ['_id', orderDir],
            ];
        const limit = (_c = first !== null && first !== void 0 ? first : last) !== null && _c !== void 0 ? _c : 100;
        const selector = Object.assign({}, query);
        if (after || before) {
            let [offset, id] = cursor_1.parseCursor(before || after);
            offset = isNaN(offset) ? offset : Number(offset);
            if (orderBy === '_id') {
                selector._id = { [operation]: id };
            }
            else {
                selector.$or = [
                    { [orderBy]: { [operation]: offset } },
                    { [orderBy]: { $eq: offset }, _id: { [operation]: id } },
                ];
            }
        }
        let [totalCount, nodes] = yield Promise.all([
            collection.countDocuments(query),
            collection
                .find(selector, { sort, limit: limit + 1, projection })
                .toArray(),
        ]);
        const hasMore = nodes.length > limit;
        const hasPreviousPage = !!(after || (last && hasMore));
        const hasNextPage = !!(before || (first && hasMore));
        nodes =
            last && !before ? nodes.splice(0, limit).reverse() : nodes.splice(0, limit);
        if (before) {
            nodes.reverse();
        }
        const edges = nodes.map((node) => ({
            node,
            cursor: cursor_1.getCursor(node, orderBy),
        }));
        const connection = {
            totalCount,
            pageInfo: {
                startCursor: ((_d = edges[0]) === null || _d === void 0 ? void 0 : _d.cursor) || undefined,
                endCursor: ((_e = edges[edges.length - 1]) === null || _e === void 0 ? void 0 : _e.cursor) || undefined,
                hasPreviousPage,
                hasNextPage,
            },
            nodes,
            edges,
        };
        if (options.type === 'nodes') {
            delete connection.edges;
        }
        if (options.type === 'edges') {
            delete connection.nodes;
        }
        return connection;
    });
}
exports.getConnection = getConnection;
//# sourceMappingURL=connection.js.map