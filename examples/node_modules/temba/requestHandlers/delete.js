import { etag } from '../etags/etags.js';
import { interceptDeleteRequest } from '../requestInterceptor/interceptRequest.js';
import { TembaError } from '../requestInterceptor/TembaError.js';
export const createDeleteRoutes = (queries, allowDeleteCollection, requestInterceptor, etagsEnabled) => {
    const handleDelete = async (req) => {
        try {
            const { headers, resource, id } = req;
            if (requestInterceptor?.delete) {
                try {
                    interceptDeleteRequest(requestInterceptor.delete, headers, resource, id);
                }
                catch (error) {
                    return {
                        status: error instanceof TembaError ? error.statusCode : 500,
                        body: { message: error.message },
                    };
                }
            }
            if (id) {
                const item = await queries.getById(resource, id);
                if (item) {
                    if (etagsEnabled) {
                        const itemEtag = etag(JSON.stringify(item));
                        if (req.etag !== itemEtag) {
                            return {
                                status: 412,
                                body: {
                                    message: 'Precondition failed',
                                },
                            };
                        }
                    }
                    await queries.deleteById(resource, id);
                }
                else {
                    // Even when deleting a non existing item, we still need an etag.
                    // The client needs to do a GET to determine it, after which it finds out the item is gone.
                    if (etagsEnabled && !req.etag) {
                        return {
                            status: 412,
                            body: {
                                message: 'Precondition failed',
                            },
                        };
                    }
                }
            }
            else {
                if (!allowDeleteCollection) {
                    return { status: 405 };
                }
                if (etagsEnabled) {
                    const items = await queries.getAll(resource);
                    const etagValue = etag(JSON.stringify(items));
                    if (req.etag !== etagValue) {
                        return {
                            status: 412,
                            body: {
                                message: 'Precondition failed',
                            },
                        };
                    }
                }
                await queries.deleteAll(resource);
            }
            return { status: 204 };
        }
        catch (error) {
            return { status: 500, body: { message: error.message } };
        }
    };
    return handleDelete;
};
//# sourceMappingURL=delete.js.map